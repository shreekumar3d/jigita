#!/usr/bin/env python3

#
# Usage notes:
#
# Before running the script,
# 1. Export environment variables that are used by KiCAD
#    e.g. export KICAD8_3DMODEL_DIR=/usr/share/kicad/3dmodels
# 2. Ensure runtime dependencies are met.  Meshlab and
#    KiCAD are used for file format conversion at this time.
#    Without them, the script will fail
#

# Standard imports
import argparse
import os
import functools
from pprint import pprint
import numpy as np
import sys
import json
import subprocess
import tempfile
import re
import copy
import math
import pathlib
import hashlib
import traceback
import platform
import shutil

# Local imports
from jigcommon import *
import jigcommon
import edge_cuts
import mesh_ops
import jigconfig
import tripy
import gen_scad
import compute_shells
import geom_ops
import ref_arrange
import shape_cache

# These are all modules you need to have
try:
    import appdirs
    import pcbnew
    import solid2
    import toml
    import shapely
    import rectpack
    import python_tsp
    import trimesh
except ImportError as err:
    print(f"Missing module : {err.name}", file=sys.stderr)
    print("Please install it using pip, and retry.")
    sys.exit(1)

import scipy.spatial
from scipy.spatial.transform import Rotation
import toml
from pcbnew import PCB_IO_MGR
from python_tsp.distances import euclidean_distance_matrix
from python_tsp.heuristics import solve_tsp_local_search, solve_tsp_simulated_annealing
from shapely import LineString, Polygon, Point


def get_courtyard_polygon(shape):
    # Courtyard Polygon Coordinate System Note:
    #
    # KiCAD returned courtyard polygons are in the KiCAD coordinate system. No need to apply
    # offset or rotation. Just negate Y
    verts = []
    # FIXME: can we have more than one outline in the courtyard !?
    if shape.OutlineCount() > 1:
        raise ValueError(
            "ERROR: can't handle courtyards with more than 1 outlines", file=sys.stderr
        )

    for i in range(shape.OutlineCount()):
        lc = shape.Outline(i)
        for j in range(lc.PointCount()):
            pt = lc.CPoint(j)
            verts.append([pcbnew.ToMM(pt.x), -pcbnew.ToMM(pt.y)])
    return verts


def get_3d_models(fp):
    models_3d = []
    for mod3d in fp.Models():
        if mod3d.m_Show:  # Don't consider hidden models
            # Skip adding this model, it if we can't find the file.
            model_filename = os.path.expandvars(mod3d.m_Filename)
            try:
                os.path.getmtime(model_filename)
            except:
                print(f'WARNING: 3d model file not found {mod3d.m_Filename}')
                print(f'                                 => {model_filename}')
                continue
            # NOTE XXX don't hold references to internal vectors - they can get
            # messed up! Make copies!
            models_3d.append(
                {
                    "model": mod3d.m_Filename,
                    "offset": [mod3d.m_Offset[0], mod3d.m_Offset[1], mod3d.m_Offset[2]],
                    "scale": [mod3d.m_Scale[0], mod3d.m_Scale[1], mod3d.m_Scale[2]],
                    "rotation": [
                        mod3d.m_Rotation[0],
                        mod3d.m_Rotation[1],
                        mod3d.m_Rotation[2],
                    ],
                }
            )
    # alphabetical order of mesh filename
    models_3d.sort(key=lambda x: x["model"])
    return models_3d


def load_footprints(cfg, fp_spec_list, arc_resolution):
    fp_map = {}
    ref_map = {}
    # FIXME: This idx business can cause obscure bugs with numbering from
    # jigconfig. Fix the right way!
    alias_idx = 1

    # User can ask for multiple copies by suffixing the spec with a number
    # in curly braces.
    # E.g. Connector_PinHeader_2.54mm:PinHeader_1x05_P2.54mm_Vertical{3}
    # will add three 2.54mm vertical pin headers
    #
    # Note that this applies on top of any glob experssions
    # E.g., Connector_PinHeader_2.54mm:PinHeader_*x05_P2.54mm_Vertical{3}
    # will give you six total, 3 of 1x5 and 3 of 2x5
    pxn = re.compile(r"^(.*)\{(\d+)\}$")

    for this_spec in fp_spec_list:
        full_spec = this_spec
        if this_spec.find(":") == -1:
            full_spec += ":*"
        fp_lib, fp_name = full_spec.split(":")
        name_rep = pxn.match(fp_name)
        if name_rep:
            fp_name = name_rep[1]
            repeat = int(name_rep[2])
            if repeat == 0:
                raise ValueError(f"Repeat count can't be 0 in {full_spec}")
        else:
            repeat = 1
        # if the lib name ends with pretty, it's a full filepath, including an
        # (optional) directory
        if not fp_lib.endswith(".pretty"):
            pretty_dir, pretty_file = os.path.split(fp_lib)
            # If no base path, then it comes from kicad
            dir_prepend = os.path.join(cfg['kicad']['share'], "footprints") if pretty_dir=='' else ''
            libpath = os.path.join(dir_prepend, f"{fp_lib}.pretty")
            fp_lib_name = fp_lib
        else:
            dirname, fname = os.path.split(fp_lib[:-7])  # remove the .pretty
            fp_lib_name = fname
            libpath = fp_lib

        src_type = PCB_IO_MGR.GuessPluginTypeFromLibPath(libpath)
        plugin = PCB_IO_MGR.PluginFind(src_type)
        if not plugin:
            raise ValueError(f"No such footprint library: {libpath}")
        lib_fp_list = plugin.FootprintEnumerate(libpath)
        none_found = True
        for name in lib_fp_list:
            fp = plugin.FootprintLoad(libpath, name)
            if not pathlib.PurePath(name).match(fp_name):
                continue
            fp_complete_name = f"{fp_lib_name}:{name}"
            fp_is_th = True if fp.GetAttributes() & pcbnew.FP_THROUGH_HOLE else False
            if not fp_is_th:
                print(f"WARNING: {fp_complete_name} is not a through hole component.")
                continue
            none_found = False
            this_alias = "FP%d" % (alias_idx)
            models_3d = get_3d_models(fp)
            if len(models_3d)==0:
                raise ValueError(f"No usable 3d models in footprint: {fp_complete_name}")
            fields = fp.Fields()
            footprint = fields[2].GetText()  # e.g. Package_QFP:LQFP-128_14x14mm_P0.4mm
            top_side_component = True if fp.GetSide() == 0 else False
            ref_info = {
                "is_th": fp_is_th,
                "x": 0,
                "y": 0,
                "orientation": 0,
                "footprint": fp_complete_name,
                "side": top_side_component,
                "models": models_3d,
                "kfp": fp,  # Reference if we need more info later
            }
            # FIXME: KiCAD doesn't return courtyard for footprints !?
            # get_courtyard_polygon(fp.GetCourtyard(pcbnew.F_CrtYd)),
            # get_courtyard_polygon(fp.GetCourtyard(pcbnew.B_CrtYd)),
            # so we take this long route - get layer drawings, combine them etc etc!
            f_crtyd_dwg = []
            b_crtyd_dwg = []
            for d in fp.GraphicalItems():
                if d.GetLayer() == pcbnew.F_CrtYd:
                    f_crtyd_dwg.append(d)
                elif d.GetLayer() == pcbnew.B_CrtYd:
                    b_crtyd_dwg.append(d)
            f_pts = edge_cuts.compute_largest_filled_shape(f_crtyd_dwg, arc_resolution)
            b_pts = edge_cuts.compute_largest_filled_shape(b_crtyd_dwg, arc_resolution)
            ref_info["front_courtyard"] = f_pts
            ref_info["back_courtyard"] = b_pts
            new_refs = []
            if repeat == 1:
                ref_map[this_alias] = ref_info
                new_refs.append(ref_info)
            else:
                for i in range(repeat):
                    this_ref = f"{this_alias}_{i}"
                    ref_map[this_ref] = copy.copy(ref_info)
                    new_refs.append(this_ref)
            fp_map[fp_complete_name] = {
                "is_th": fp_is_th,
                "refs": new_refs,
                "alias": this_alias,
                "footprint": fp,
                "display_name": fp_complete_name,
                "force_smd": False,
                "base_footprint": fp,
            }
            alias_idx += 1
        if none_found:
            raise ValueError(f"No usable matches for {this_spec}")

    return ref_map, fp_map


def xform_mesh(mesh_in, modinfo, flip_side=False, pcb_thickness=1.6):
    mesh = mesh_in.copy()  # don't change source mesh
    mesh.apply_scale(modinfo["scale"])
    # FIXME: Hrrmph! why should I need to reverse these
    # angles !?
    mat = trimesh.transformations.euler_matrix(
        np.radians(-modinfo["rotation"][0]),
        np.radians(-modinfo["rotation"][1]),
        np.radians(-modinfo["rotation"][2]),
    )
    mesh.apply_transform(mat)
    mesh.apply_translation(
        [modinfo["offset"][0], modinfo["offset"][1], modinfo["offset"][2]]
    )
    if flip_side:
        # flip mesh
        flip_mat = trimesh.transformations.euler_matrix(
                0, np.radians(180), 0)
        mesh.apply_transform(flip_mat)
        # FIXME: this is getting a bit ugly. A flipped part
        # would be oriented to properly align with PCB edge on the
        # opposite side, implicitly accounting for PCB thickness.
        # we need to reverse this by...
        # reversing the compensation for PCB thickness
        mesh.apply_translation([0,0,-pcb_thickness])

    vertices = np.array(mesh.vertices)
    min_z = min(vertices[:, 2])
    max_z = max(vertices[:, 2])
    return vertices, mesh, min_z, max_z


def get_ref_info(fp_list, unity_xform):
    mounting_holes = {}
    ref_map = {}
    fp_map = {}
    for fp in fp_list:
        ref = fp.GetReference()
        fp_x = units_to_mm(fp.GetX())
        fp_y = -units_to_mm(fp.GetY())
        fp_is_th = True if fp.GetAttributes() & pcbnew.FP_THROUGH_HOLE else False
        # print(fp.GetReference())
        # print('  Position(mm):', fp_x, fp_y)
        # print('  On side     :', fp.GetSide())
        # print('  Orientation :', fp.GetOrientation().AsDegrees())
        # print('  DNP ?       :', fp.IsDNP())
        # print('  TH ?        :', fp_is_th)
        models_3d = get_3d_models(fp)
        fp_rot = fp.GetOrientation().AsDegrees()
        fields = fp.Fields()
        footprint = fields[2].GetText()  # e.g. Package_QFP:LQFP-128_14x14mm_P0.4mm
        if len(footprint)==0:
            # If we don't get a footprint, use FPID
            # (some boards don't have this - e.g. mixolydian-4x4)
            # FIXME is there an implicit bug here ? figure out this mystery and
            # crack what is what. is there an implicit override order here?
            footprint = fp.GetFPIDAsString()
        top_side_component = True if fp.GetSide() == 0 else False
        ref_info = {
            "is_th": fp_is_th,
            "footprint": footprint,
            "side": top_side_component,
            "position": fp.GetPosition(),
            "models": models_3d,
            "kfp": fp,  # Reference if we need more info later
            "front_courtyard": get_courtyard_polygon(fp.GetCourtyard(pcbnew.F_CrtYd)),
            "back_courtyard": get_courtyard_polygon(fp.GetCourtyard(pcbnew.B_CrtYd)),
        }
        ref_info["x"] = fp_x if not unity_xform else 0
        ref_info["y"] = fp_y if not unity_xform else 0
        ref_info["orientation"] = fp_rot if not unity_xform else 0

        is_mounting_hole = False
        if fp.HasThroughHolePads():
            could_be_mh = False
            for fn in fp.Fields():
                if fn.GetText().startswith("MountingHole"):
                    could_be_mh = True
                    break
            if could_be_mh:
                # mounting hole could have multiple pads - corresponding to copper, drill, etc
                for pad in fp.Pads():
                    ds = pad.GetDrillSize()
                    if ds[0] == 0 or ds[1] == 0:  # It could be a pad, not a drill
                        continue
                    if pad.GetShape() != 0:
                        print(
                            "WARNING: No support for non-circular mounting holes",
                            file=sys.stderr,
                        )
                        continue
                    ref_info["mounting_hole_radius"] = units_to_mm(ds[0]) * 0.5
                    # print('Mounting hole:', ref,
                    #      ' at (%s,%s)'%(fp_x, -fp_y), # show in KiCAD coords
                    #      ' size=', ref_info['mounting_hole_radius'])
                    is_mounting_hole = True
                    break
        ref_info["is_mounting_hole"] = is_mounting_hole
        if len(models_3d)==0:
            if not is_mounting_hole:
                print(f"WARNING: {ref} has no meshes. Removed from configuration.")
        else:
            ref_map[ref] = ref_info

        # remember that this footprint has this ref
        if not is_mounting_hole:
            if footprint in fp_map:
                fp_map[footprint]["refs"].append(ref)
            else:
                fp_map[footprint] = {
                    "is_th": fp_is_th,
                    "refs": [ref],
                    "alias": None,
                    "display_name": None,
                    "force_smd": False,
                }
        else:
            mounting_holes[ref] = ref_info

        # print(fp.Footprint().GetName())
        # pprint(dir(fp.Footprint()))
    return ref_map, fp_map, mounting_holes


def load_ref_3d_models(cfg, ref, ref_map):
    scriptdir = os.path.dirname(os.path.realpath(__file__))
    temp_dir = (
        os.path.expanduser(os.environ["TMPDIR"]) if "TMPDIR" in os.environ else None
    )
    value_type = cfg["cache"]["method"]
    comp = ref_map[ref]
    metadata = {
        "files": [],
    }

    for modinfo in comp["models"]:
        model_filename = os.path.expandvars(modinfo["model"])
        try:
            modinfo["mesh"], modinfo["mtime"], modinfo["mesh_hash"] = mesh_ops.load_mesh(
                cfg, model_filename, scriptdir, temp_dir
            )
        except FileNotFoundError as e:
            modinfo['mesh'] = mesh_ops.empty_mesh()
            modinfo['mtime'] = 0
            modinfo['mesh_hash'] = ""
            print(f'WARNING: 3d model file ${model_filename} not found')
        metadata["files"].append(
            {
                "file": modinfo["model"],
                "ts": modinfo["mtime"],
                "hash": modinfo["mesh_hash"],
            }
        )
    return metadata


def load_3d_models(ref_list, ref_map, desc):
    temp_dir = (
        os.path.expanduser(os.environ["TMPDIR"]) if "TMPDIR" in os.environ else None
    )
    scriptdir = os.path.dirname(os.path.realpath(__file__))
    fnames = []
    for ref in ref_list:
        comp = ref_map[ref]
        for modinfo in comp["models"]:
            model_filename = os.path.expandvars(modinfo["model"])
            fnames.append(model_filename)
    # get uniques
    fnames = list(set(fnames))
    print(f"Loading {len(fnames)} 3D models for {desc} components...")
    for ref in ref_list:
        load_ref_3d_models(cfg, ref, ref_map)


def body_id(cfg, ref, flip_side=False, pcb_thickness=1.6, force_mount=False):
    model_names = []
    for modinfo in ref["models"]:
        model_names.append(
            [modinfo["model"], modinfo["rotation"], modinfo["offset"], modinfo["scale"]]
        )

    # FIXME PCB thickness and force_mount here are ultra ugly, but safe!
    full_name = '%s_%s_%s_'%(flip_side, pcb_thickness, force_mount)
    for values in model_names:
        for x in values:
            full_name += str(x)
    # body id includes other parameters that impact the geometry of the
    # shells. any change to these must trigger a "rebuild"
    full_name += str(cfg["3dprinter"]["min_printable_hole_area"])

    return hashlib.md5(bytes(full_name, "utf-8")).hexdigest()


#
# Execution starts here
#
parser = argparse.ArgumentParser(
    description="Create jigs in a jiffy", epilog="Use the examples, Luke!"
)

group = parser.add_mutually_exclusive_group(required=True)
group.add_argument(
    "--examples", default=False, action="store_true", help="""Shows examples of usage"""
)
group.add_argument(
    "-i", "--pcb", metavar="FILENAME", help="KiCAD PCB file (.kicad_pcb) to process"
)
group.add_argument(
    "--footprint",
    metavar="SPEC",
    action="extend",
    nargs="+",
    type=str,
    help="""Generate a shell for specified kicad library footprint(s),
instead of a PCB. Use --examples for info on SPEC""",
)
group.add_argument(
    "--model3d",
    action="extend",
    nargs="+",
    type=str,
    help="""Generate a shell from 3D model(s).""",
)
group.add_argument(
    "--show-paths",
    action="store_true",
    default=False,
    help="""Show various paths used by the tool. Useful for
debugging when something isn't working.
""",
)

parser.add_argument(
    "--pcb-footprints",
    action="store_true",
    default=False,
    help="""Generates one shell per footprint used on the PCB design
            given through --pcb.""",
)
parser.add_argument(
    "--bottom-components",
    action="store_true",
    default=False,
    help="""Process components on the bottom side of the PCB. By default
            we process top side components.""",
)
parser.add_argument(
    "--arrange",
    default="xy",
    choices=["x", "y", "xy", "grid", "grid_xy", "grid_yx"],
    help="""Arrange shells in this direction. grid is same as grid_xy. Works with --footprint,
            --model3d and --pcb-footprints""",
)
parser.add_argument(
    "--gap",
    metavar="GAP_XY|GAP_X,GAP_Y",
    help="""Gap around shells. You may provie a single value, or separate values
            for X and Y axes. Applies with --arrange""",
)
parser.add_argument(
    "--grid",
    metavar="X,Y",
    help="""Arrange shells in an X by Y grid. Applies with --arrange""",
)
parser.add_argument(
    "--topmost-z",
    type=float,
    help="""Specify the height of the jig(in mm), excluding the base
            and PCB holder if any(in mm). The value you provide cannot
            be smaller than the computed value (based on the 3D shapes
            of the components)""",
)
parser.add_argument(
    "-c",
    "--config",
    metavar="FILENAME.toml",
    help="Use this configuration options file for various parameters.",
)

parser.add_argument("-o", "--output", help="Output file.")
parser.add_argument(
    "-f",
    "--output-format",
    choices=["3mf", "stl", "scad"],
    help="Output file format. Default autodect based on output file extension.",
)
parser.add_argument(
    "--keep-orientation",
    action="store_true",
    default=False,
    help="""Match orientation of the output to KiCAD 3D view.
The default orients the output for direct printing (i.e. rotated by 180 degrees
along the X axis.)""",
)
parser.add_argument(
    "--dump-config",
    metavar="FILENAME.toml",
    help="""Save a copy of the effective configuration after applying
    internal defaults, user and config file.""",
)
parser.add_argument(
    "--genconfig",
    metavar="FILENAME.toml",
    help="""Generate a default configuration file, from an
    input KiCAD PCB. This lists all footprint and components.
    User friendly openscad output can be generated, starting
    with that as the base""",
)
parser.add_argument(
    "--enable-smd-shells",
    action="store_true",
    default=False,
    help="""Experimental: Generate shells for SMD components.
Using this disables SMD keepouts.
""",
)

group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", help="Verbose messages")
group.add_argument("-q", "--quiet", help="Info messages are suppressed")
args = parser.parse_args()

# Validate command line parameter requirements
if args.pcb_footprints and not args.pcb:
    print(f"--pcb-footprints requires --pcb", file=sys.stderr)
    sys.exit(1)

# start with defaults. FIXME: can this come from elsewhere - like a config ?
gap_y = gap_x = 10.0

if args.gap:
    if not (args.pcb_footprints or args.footprint or args.model3d):
        print(
            "--gap requires at-least one of --pcb-footprints, --footprint or --model3d"
        )
        sys.exit(1)
    parts = args.gap.split(",")
    if len(parts) > 2:
        print(
            f'ERROR: Upto 2 comma separated values may be specified for gap. Supplied="{args.gap}"'
        )
        sys.exit(1)

    try:
        gap_x = float(parts[0])
        gap_y = float(parts[1]) if len(parts) > 1 else gap_x
    except ValueError:
        print(f'ERROR: bad value for gap="${args.gap}"')
        sys.exit(1)

grid_x = grid_y = 1
if args.arrange in ["grid", "grid_xy", "grid_yx"]:
    if not args.grid:
        print("--arrange=grid requires grid size in --grid")
        sys.exit(1)
    if not (args.pcb_footprints or args.footprint or args.model3d):
        print(
            "--arrange=grid requires at-least one of --pcb-footprints, --footprint or --model3d"
        )
        sys.exit(1)
    parts = args.grid.split(",")
    if len(parts) != 2:
        print(
            f'ERROR: 2 comma separated values must be specified for grid. Supplied="{args.grid}"'
        )
        sys.exit(1)
    try:
        grid_x = int(parts[0])
        grid_y = int(parts[1])
    except ValueError:
        print(f'ERROR: bad value for grid="${args.grid}"')
        sys.exit(1)

    # We allow a value of "1". Grid centers parts small and large,
    # so a dimension of "1" is not the same as arrange by X or Y
    if grid_x <= 0 or grid_y <= 0:
        print(f'ERROR: bad value for grid="${args.grid}"')
        sys.exit(1)

if args.examples:
    print(f"Sorry, examples aren't created yet. Use the source, Luke!", file=sys.stderr)
    sys.exit(1)

jigconfig.load_user_config(jigcommon.APP_NAME)

try:
    cfg, config_text, default_cfg = jigconfig.load_config(args.config)
except ValueError as err:
    print(f"ERROR in load config: {err}", file=sys.stderr)
    sys.exit(-1)

# Setup environment for file name expansion
# First take from user config
for env_var_name in cfg["environment"]:
    os.environ[env_var_name] = cfg["environment"][env_var_name]
if args.pcb:
    pcb_dir, pcb_file = os.path.split(args.pcb)
    os.environ["KIPRJMOD"] = '.' if pcb_dir=='' else pcb_dir
else:
    os.environ["KIPRJMOD"] = '.'

path_sys_3dmodels = os.path.join(cfg["kicad"]["share"], "3dmodels")

# Now add onto it, this allows overrides from user config
for ver in ["", 6, 7, 8]:  # Hmm - would we need more ?
    env_var_name = "KICAD%s_3DMODEL_DIR" % (ver)
    if env_var_name not in os.environ:
        os.environ[env_var_name] = path_sys_3dmodels

# Expand paths
cfg["openscad"]["binary"] = os.path.expanduser(cfg["openscad"]["binary"])
cfg["kicad"]["share"] = os.path.expanduser(cfg["kicad"]["share"])

if args.footprint:
    try:
        # FIXME: how do we decide 1.0 is the tesellation resolution?
        # sure its good enough for courtyard polys!
        ref_map, fp_map = load_footprints(cfg, args.footprint, 1.0)
    except ValueError as err:
        print(f"ERROR: {err}", file=sys.stderr)
        sys.exit(-1)
    mh_map = {}

if args.model3d:
    print(f"Sorry, the model3d option isn't implemented yet", file=sys.stderr)
    sys.exit(1)

# determine extension
if args.output and not args.output_format:
    out_split = os.path.splitext(args.output)
    out_ext = out_split[1]  # will be empty string if no extension
    if out_ext in [".3mf", ".stl", ".scad"]:
        args.output_format = out_ext[1:]
    if not args.output_format:
        print(
            f"Unrecorgnized extension in output filename '{args.output}'",
            file=sys.stderr,
        )
        sys.exit(1)
    # We'll invoke openscad later for non-OSCAD files. Check and
    # inform the user if we can't access it.
    if out_ext != '.scad':
        oscad_bin = cfg['openscad']['binary']
        if not shutil.which(oscad_bin):
            print(
                f"Unable to find openscad binary {oscad_bin} . Use --show-paths to resolve.",
                file=sys.stderr,
            )
            sys.exit(1)

if args.show_paths:
    config_error = False
    print('User specific configuration file loaded on startup :',
            os.path.join(appdirs.user_config_dir(jigcommon.APP_NAME),"config.toml")
         )
    print('Cache directory :', (appdirs.user_cache_dir(jigcommon.APP_NAME)))
    kicad_share_dir = cfg['kicad']['share']
    if os.path.isdir(kicad_share_dir):
        if not os.path.isdir(os.path.join(kicad_share_dir,'3dmodels')):
            kicad_share_staus = \
                'Found, but potentially incorrect dir. Command may fail ' \
                'to access important kicad files.'
            config_error = True
        else:
            kicad_share_status = 'OK'
    else:
        kicad_share_status = \
            'Not found. Command may fail to access important kicad files.'
    print('KiCAD share directory : %s => %s'%(cfg["kicad"]["share"], kicad_share_status))
    oscad_bin = cfg["openscad"]["binary"]
    oscad_bin_resolved = shutil.which(oscad_bin)
    if oscad_bin_resolved:
        msg = oscad_bin_resolved
    else:
        if os.path.isabs(oscad_bin):
            msg = 'Binary not found.'
        else:
            msg = 'Not found on PATH.'
        msg += ' Command will fail to generate STL/3MF files.'
    print('OpenSCAD binary : %s => %s'%(
            oscad_bin,
            msg
          )
         )
    sys.exit(0)

if args.pcb:
    board = pcbnew.LoadBoard(args.pcb)
    ref_map, fp_map, mh_map = get_ref_info(board.Footprints(), args.pcb_footprints)
if args.genconfig:
    jigconfig.generate_config(args.genconfig, ref_map, fp_map)
    print(f"Generated : {args.genconfig}")
    sys.exit(0)

try:
    cfg, used_th_fp, th_ref_list, smd_ref_list = jigconfig.update(
        cfg, default_cfg, ref_map, fp_map, mh_map
    )
except ValueError as err:
    print(f"ERROR in validate config: {err}", file=sys.stderr)
    sys.exit(-1)
# pprint(cfg)

if args.pcb:
    # Remove components on side of the PCB that we aren't interested in...
    # Also, reorient flip_side components
    cull_th_refs = []
    cull_smd_refs = []
    for ref in ref_map:
        ref_info = ref_map[ref]
        if not ref_info["is_th"]:
            if ref_info['side'] != (not args.bottom_components):
                cull_smd_refs.append(ref)
            continue
        # ref might be trimmed due to exclusion, nothing to do
        # FIXME this looks a bit ugly. Rethink how this included, exclude,
        # expansion etc is supposed to work
        if ref not in cfg['TH']:
            continue
        if cfg["TH"][ref]['flip_side']:
            ref_info['side'] = not ref_info['side']
            ref_info['orientation'] = 180+ref_info['orientation']
        if ref_info['side'] != (not args.bottom_components):
            # on other side, so add to cull list
            cull_th_refs.append(ref)
    #print("Culling TH ", cull_th_refs)
    #print("Culling SMD ", cull_th_refs)
    for ref in cull_th_refs:
        ref_map.pop(ref)
        th_ref_list.remove(ref)
    for ref in cull_smd_refs:
        ref_map.pop(ref)
        smd_ref_list.remove(ref)
    used_th_fp = []
    for ref in th_ref_list:
        used_th_fp.append(cfg["TH"][ref]["kicad_footprint"])
    used_th_fp = list(set(used_th_fp))

if args.pcb and args.pcb_footprints:
    # trim th_ref_list. Keep only one component per footprint
    final_ref_list = []
    for key in fp_map:
        if fp_map[key]["is_th"] and not fp_map[key]["force_smd"]:
            ref_list = fp_map[key]["refs"]
            retain_ref = ref_list[0]
            final_ref_list.append(retain_ref)
            # remove the rest
            for comp_ref in ref_list[1:]:
                ref_map.pop(comp_ref)
    th_ref_list = final_ref_list
    print(
        f"Selected {len(th_ref_list)} unique footprint(s) on the board:",
        ",".join(th_ref_list),
    )

mounting_holes = []
for name in mh_map.keys():
    mounting_holes.append([mh_map[name]["x"], mh_map[name]["y"]])

if args.dump_config:
    with open(args.dump_config, "w") as fp:
        toml.dump(cfg, fp)

if not args.output:
    print(f"ERROR: Need an output file", file=sys.stderr)
    sys.exit(-1)

if args.pcb:
    do_pcb_proc = True if not args.pcb_footprints else False
else:
    do_pcb_proc = False

pcb_thickness = cfg["pcb"]["thickness"]
shell_clearance = cfg["TH"]["component_shell"]["shell_clearance_from_pcb"]
shell_type = cfg["TH"]["component_shell"]["shell_type"]
shell_gap = cfg["TH"]["component_shell"]["shell_gap"]
shell_thickness = cfg["TH"]["component_shell"]["shell_thickness"]

arc_resolution = cfg["pcb"]["tesellate_edge_cuts_curve"]

base_line_width = cfg["holder"]["base"]["line_width"]
base_line_height = cfg["holder"]["base"]["line_height"]
pcb_perimeter_height = cfg["holder"]["base"]["perimeter_height"]
pcb_holder_gap = cfg["holder"]["pcb_gap"]
pcb_holder_overlap = cfg["holder"]["pcb_overlap"]
pcb_holder_perimeter = cfg["holder"]["perimeter"]
forced_pcb_supports = cfg["holder"]["forced_grooves"]
groove_size = cfg["holder"]["groove_size"]
ref_do_not_process = cfg["TH"]["refs_do_not_process"]
ref_process_only_these = cfg["TH"]["refs_process_only_these"]
jig_type = cfg["jig"]["type"]
jig_type_component_fitting = jig_type == "component_fitting"
smd_clearance_from_shells = cfg["SMD"]["clearance_from_shells"]
smd_gap_from_shells = cfg["SMD"]["gap_from_shells"]
printable_threshold = cfg["3dprinter"]["min_printable_hole_area"]
if jig_type_component_fitting:
    if shell_clearance > 0:
        print(
            "INFO: Generating component shells, note shell_clearance=%s will cut into shell."
            % (shell_clearance)
        )

# load_3d_models(th_ref_list, ref_map, 'Through Hole')
# load_3d_models(smd_ref_list, ref_map, 'SMD')

if args.output_format in ["3mf", "stl"]:
    # FreeCAD 8.0.9 ships with Python 3.11.5
    # we'll delete the file as cleanup
    fp_scad = tempfile.NamedTemporaryFile(
        mode="w", suffix=".scad", delete=False
    )
    oscad_filename = fp_scad.name
    out_filename = args.output
else:
    oscad_filename = args.output
    fp_scad = open(oscad_filename, "w")

pcb_segments = []
pcb_filled_shapes = []
seg_shapes = []


if do_pcb_proc:
    edge_cuts.load(board, pcb_segments, pcb_filled_shapes)
    if not edge_cuts.coalesce_segments(pcb_segments, seg_shapes):
        print("ERROR: Please check the edge cuts layer in KiCAD.")
        print("ERROR: There are incomplete outlines. DRC or 3D View should help")
        print("ERROR: diagnose the issue")
        sys.exit(-1)

    edge_cuts.tesellate(arc_resolution, seg_shapes, pcb_filled_shapes)
    edge_cuts.compute_areas(pcb_filled_shapes)

    if len(pcb_filled_shapes) == 0:
        print("ERROR: At-least one filled shape is needed in Edge.Cuts layer")
        print("Please check and validate board file.")
        sys.exit(-1)

    # Find the largest filled area. This is assumed to be the actual
    # PCB outline
    pcb_filled_shapes.sort(key=lambda x: x["area"], reverse=True)
    # And hence these are the vertices
    pcb_edge_points = copy.deepcopy(pcb_filled_shapes[0]["vertices"])
    # Fix Y immediately - don't let the disease spread :)
    # FIXME I really need some coordinated way of setting up the coordinate
    # system
    for pt in pcb_edge_points:
        pt[1] = -pt[1]

all_shells = []
fp_centers = []
topmost_z = 0

all_bids = []
all_th_zs = {}
# For each TH component on the board
for this_ref in th_ref_list:
    print("Processing TH :", this_ref)
    # each footprint can have multiple models.
    # each model that is "in contact" with the board will generate
    # a shell
    local_max_z = 0
    local_min_z = float("inf")
    subshells = {"ref": this_ref, "shell": [], "courtyard": None}
    th = ref_map[this_ref]
    th_flip_side = cfg["TH"][this_ref]["flip_side"]
    th_force_mount = cfg["TH"][this_ref]['force_mount']
    this_bid = body_id(cfg, th, th_flip_side, cfg['pcb']['thickness'], th_force_mount)
    if this_bid in all_bids:
        print('Repeated shape: ' , this_ref)
    all_bids.append(this_bid)
    body_info = shape_cache.get_cached_bid(cfg, "th", this_bid, th["footprint"])
    if not body_info:
        new_body_metadata = load_ref_3d_models(cfg, this_ref, ref_map)
        new_body_info = {"subshells": []}
    else:
        new_body_info = None
    for idx, modinfo in enumerate(th["models"]):
        ss_info = {}
        mverts = None
        if not body_info:
            mesh = modinfo["mesh"]
            mverts = np.array(mesh.vertices)
            if mverts.shape[0] == 0:
                print(
                    "ERROR: Component %s, Mesh %s is empty on import. Please fix, or exclude this component."
                    % (this_ref, modinfo["model"], this_ref)
                )
                sys.exit(1)

        if not body_info:
            mverts, mesh, min_z, max_z = xform_mesh(mesh, modinfo, th_flip_side, cfg['pcb']['thickness'])
            min_x = min(mverts[:, 0])
            max_x = max(mverts[:, 0])
            min_y = min(mverts[:, 1])
            max_y = max(mverts[:, 1])
            center_x = (min_x + max_x) / 2
            center_y = (min_y + max_y) / 2
            h_bins = compute_shells.fitting_pockets(mverts, 0.5, printable_threshold)
            for this_bin in h_bins:
                this_bin["corners"], this_bin["corner_segments"] = (
                    geom_ops.extract_corners_2D(this_bin["hull"])
                )
            # FIXME: tight pockets computes z slices on the mesh
            # if the mesh isn't tight, that doesn't work. trimesh will throw
            # errors on various Z values - which we ignore. The remaining Z
            # values hopefully are enough to reconstruct the object.
            # this is a reasonable decision for now. The user is warned.
            # fitting and fitting_flowers are computed using hulls computed
            # over the vertices, so those aren't impacted. Overall, the user always
            # has something correct to work with, even though they may have a bad mesh
            # We don't repair meshes here, and it's an open question if we
            # should even try that.
            c_bins = compute_shells.tight_pockets(mesh, 0.5, printable_threshold)
            for this_bin in c_bins:
                this_bin['corners'] = []
                this_bin['corner_segments'] = []
                for this_shape in this_bin['shapes']:
                    corners, corner_segments = (
                        geom_ops.extract_corners_2D(this_shape)
                    )
                    this_bin['corners'].append(corners)
                    this_bin['corner_segments'].append(corner_segments)
            ss_info["min_x"] = min_x
            ss_info["max_x"] = max_x
            ss_info["min_y"] = min_y
            ss_info["max_y"] = max_y
            ss_info["min_z"] = min_z
            ss_info["max_z"] = max_z
            ss_info["center_x"] = center_x
            ss_info["center_y"] = center_y
            ss_info["h_bins"] = h_bins
            ss_info["c_bins"] = c_bins
        else:
            ss_info = body_info["subshells"][idx]
            min_x = ss_info["min_x"]
            min_y = ss_info["min_y"]
            max_x = ss_info["max_x"]
            max_y = ss_info["max_y"]
            min_z = ss_info["min_z"]
            max_z = ss_info["max_z"]
            center_x = ss_info["center_x"]
            center_y = ss_info["center_y"]
            h_bins = ss_info["h_bins"]
            c_bins = ss_info["c_bins"]

        if (not th_force_mount) and min_z > 0:
            print("  Mesh %s is NOT mounted on board. min_z = %s; Skipping." % (modinfo["model"], min_z))
        else:
            if th_force_mount:
                min_z = 0.0
            shell_ident = "%s_%d" % (this_ref, idx)
            # compute the center now, post cache. x, y, and orientation
            # are per component
            rz2 = Rotation.from_euler("z", th["orientation"], degrees=True)
            c_pt = np.array([[center_x, center_y, 0]])
            c_pt = rz2.apply(c_pt)
            c_pt = c_pt + [th["x"], th["y"], 0]
            c_pt = [c_pt[0][0], c_pt[0][1]]
            fp_centers.append(c_pt)
            this_subshell = {
                "name": shell_ident,
                "min_z": min_z,
                "max_z": max_z,
                "model": modinfo["model"],
                "fp_center": c_pt,
                "fitting_bins": h_bins,
                "tight_bins": c_bins,
            }
            this_subshell["x"] = th["x"]
            this_subshell["y"] = th["y"]
            # Shells of bottom components need rotation around Z
            # but this is not enough. Z needs to be flipped also, see
            # gen_scad.py, scale -1 of Z
            if th['side']:
                this_subshell["orientation"] = th["orientation"]
            else:
                this_subshell["orientation"] = 180+th["orientation"]
            subshells["shell"].append(this_subshell)
            this_subshell["min_x"] = min_x
            this_subshell["max_x"] = max_x
            this_subshell["min_y"] = min_y
            this_subshell["max_y"] = max_y
            print(
                "  Generating shell %s for ref %s with mesh %s"
                % (shell_ident, this_ref, modinfo["model"])
            )
            local_max_z = max(local_max_z, max_z)
            local_min_z = min(local_min_z, min_z)
        if not body_info:
            new_body_info["subshells"].append(ss_info)
    if len(subshells["shell"]) > 1:
        all_hulls = None
        for ss in subshells["shell"]:
            # first bin is the biggest one
            this_hull = ss["fitting_bins"][0]["hull"]
            if all_hulls is None:
                all_hulls = np.copy(this_hull)
            else:
                all_hulls = np.concatenate((this_hull, all_hulls), axis=0)
        hull = scipy.spatial.ConvexHull(all_hulls)
        hull_verts = all_hulls[hull.vertices]
        subshells["combined_hull"] = hull_verts

    topmost_z = max(topmost_z, local_max_z)

    if local_max_z == 0:  # 0 means empty mesh, so avoid infs
        local_min_z = 0

    subshells["max_z"] = local_max_z
    subshells["min_z"] = local_min_z
    if th['side']:
        subshells["courtyard"] = th["front_courtyard"]
    else:
        subshells["courtyard"] = th["back_courtyard"]
    subshells["ref_type"] = "TH"
    all_shells.append(subshells)
    if new_body_info:
        shape_cache.add_cached_bid(
            cfg, "th", this_bid, new_body_info, new_body_metadata, th["footprint"]
        )
    if local_max_z not in all_th_zs:
        all_th_zs[local_max_z] = [ th['footprint'] ]
    else:
        if th['footprint'] not in all_th_zs[local_max_z]:
            all_th_zs[local_max_z].append(th['footprint'])

if args.topmost_z:
    if args.topmost_z < topmost_z:
        print(
            f"ERROR: Specified value {args.topmost_z} has to be >= computed value {topmost_z}"
        )
        sys.exit(1)
    else:
        topmost_z = args.topmost_z
all_bids = list(set(all_bids))
all_max_z = list(all_th_zs.keys())
all_max_z.sort()
print(f"INFO: Board has {len(all_shells)} shells in {len(all_bids)} unique body shapes")
print('max_Zs:')
for val in all_max_z:
    fp_names = ','.join(all_th_zs[val])
    print(f'  {val:>4.2f} : {fp_names}')
dup_fp = shape_cache.get_fp_duplicates()
if len(dup_fp) > 0:
    print(f"WARNING: The following footprints have multiple body shapes. Please check")
    for fp_name in dup_fp:
        print(fp_name, " has ", dup_fp[fp_name], " shapes")
unique_fps = []
for key in fp_map:
    if fp_map[key]["is_th"] and not fp_map[key]["force_smd"]:
        unique_fps.append(key)
    unique_fps = list(set(unique_fps))
print(f"Number of unique footprints: {len(unique_fps)}")
unique_fps.sort()
pprint(unique_fps)
if do_pcb_proc:
    smd_keepouts = []
    for this_ref in smd_ref_list:
        local_max_z = 0
        local_min_z = float("inf")
        subshells = {"ref": this_ref, "shell": [], "courtyard": None}
        smd = ref_map[this_ref]
        this_bid = body_id(cfg, smd)
        body_info = shape_cache.get_cached_bid(cfg, "smd", this_bid, smd["footprint"])
        if not body_info:
            new_body_metadata = load_ref_3d_models(cfg, this_ref, ref_map)
            new_body_info = {"subshells": []}
        else:
            new_body_info = None
        # print('Processing SMD :', this_ref)
        # each footprint can have multiple models.
        # each model that is "in contact" with the board will generate
        # a shell
        for idx, modinfo in enumerate(smd["models"]):
            ss_info = {}
            mverts = None
            if not body_info:
                mesh = modinfo["mesh"]
                mverts = np.array(mesh.vertices)
                if mverts.shape[0] == 0:
                    print(
                        "ERROR: Component %s, Mesh %s is empty on import. Please fix, or exclude this component."
                        % (this_ref, modinfo["model"])
                    )
                    sys.exit(1)

            if not body_info:
                mverts, mesh, min_z, max_z = xform_mesh(mesh, modinfo)
                # FIXME: reduce code duplication after hackathon
                min_x = min(mverts[:, 0])
                max_x = max(mverts[:, 0])
                min_y = min(mverts[:, 1])
                max_y = max(mverts[:, 1])
                ss_info["min_z"] = min_z
                ss_info["max_z"] = max_z
                center_x = (min_x + max_x) / 2
                center_y = (min_y + max_y) / 2
                # FIXME: bin_size=0.1 could be configurable
                print("Computing fitting_pockets for ", this_ref)
                h_bins = compute_shells.fitting_pockets(
                    mverts, 0.1, printable_threshold
                )
                for this_bin in h_bins:
                    this_bin["corners"], this_bin["corner_segments"] = (
                        geom_ops.extract_corners_2D(this_bin["hull"])
                    )
                c_bins = compute_shells.tight_pockets(mesh, 0.5, printable_threshold)
                for this_bin in c_bins:
                    this_bin['corners'] = []
                    this_bin['corner_segments'] = []
                    for this_shape in this_bin['shapes']:
                        corners, corner_segments = (
                            geom_ops.extract_corners_2D(this_shape)
                        )
                        this_bin['corners'].append(corners)
                        this_bin['corner_segments'].append(corner_segments)
                ss_info["min_x"] = min_x
                ss_info["max_x"] = max_x
                ss_info["min_y"] = min_y
                ss_info["max_y"] = max_y
                ss_info["min_z"] = min_z
                ss_info["max_z"] = max_z
                ss_info["center_x"] = center_x
                ss_info["center_y"] = center_y
                ss_info["h_bins"] = h_bins
                ss_info["c_bins"] = c_bins
            else:
                ss_info = body_info["subshells"][idx]
                min_z = ss_info["min_z"]
                max_z = ss_info["max_z"]
                min_x = ss_info["min_x"]
                min_y = ss_info["min_y"]
                max_x = ss_info["max_x"]
                max_y = ss_info["max_y"]
                min_z = ss_info["min_z"]
                max_z = ss_info["max_z"]
                center_x = ss_info["center_x"]
                center_y = ss_info["center_y"]
                h_bins = ss_info["h_bins"]
                c_bins = ss_info["c_bins"]

            shell_ident = "%s_%d" % (this_ref, idx)

            rz2 = Rotation.from_euler("z", smd["orientation"], degrees=True)
            c_pt = np.array([[center_x, center_y, 0]])
            c_pt = rz2.apply(c_pt)
            c_pt = c_pt + [smd["x"], smd["y"], 0]
            c_pt = [c_pt[0][0], c_pt[0][1]]
            this_subshell = {
                "name": shell_ident,
                "min_z": min_z,
                "max_z": max_z,
                "model": modinfo["model"],
                "fp_center": c_pt,
                "fitting_bins": h_bins,
                "tight_bins": c_bins,
            }
            this_subshell["x"] = smd["x"]
            this_subshell["y"] = smd["y"]
            this_subshell["orientation"] = smd["orientation"]
            this_subshell["min_x"] = min_x
            this_subshell["max_x"] = max_x
            this_subshell["min_y"] = min_y
            this_subshell["max_y"] = max_y
            local_max_z = max(local_max_z, max_z)
            local_min_z = min(local_min_z, min_z)

            # Shells and keepouts are exclusive for now
            # as both can't be used together
            # FIXME: perhaps SMD keepouts should be applied in
            # a different order ?
            if args.enable_smd_shells:
                fp_centers.append(c_pt)
                subshells["shell"].append(this_subshell)
                print(
                    "  Generating shell %s for ref %s with mesh %s"
                    % (shell_ident, this_ref, modinfo["model"])
                )
            else:
                smd_keepouts.append(
                    {
                        "name": shell_ident,
                        "ref": this_ref,
                        "min_z": min_z,
                        "max_z": max_z,
                        "model": modinfo["model"],
                        "x": smd["x"],
                        "y": smd["y"],
                        "orientation": smd["orientation"],
                        "courtyard": smd["front_courtyard" if smd['side'] else "back_courtyard"],
                    }
                )
            topmost_z = max(topmost_z, max_z)
            if not body_info:
                new_body_info["subshells"].append(ss_info)
        if len(subshells["shell"]) > 1:
            all_hulls = None
            for ss in subshells["shell"]:
                # first bin is the biggest one
                this_hull = ss["fitting_bins"][0]["hull"]
                if all_hulls is None:
                    all_hulls = np.copy(this_hull)
                else:
                    all_hulls = np.concatenate((this_hull, all_hulls), axis=0)
            hull = scipy.spatial.ConvexHull(all_hulls)
            hull_verts = all_hulls[hull.vertices]
            subshells["combined_hull"] = hull_verts
        topmost_z = max(topmost_z, local_max_z)

        if local_max_z == 0:  # 0 means empty mesh, so avoid infs
            local_min_z = 0

        subshells["max_z"] = local_max_z
        subshells["min_z"] = local_min_z
        if smd['side']:
            subshells["courtyard"] = smd["front_courtyard"]
        else:
            subshells["courtyard"] = smd["back_courtyard"]
        subshells["ref_type"] = "SMD"

        # Don't include if SMD isn't enabled
        if args.enable_smd_shells:
            all_shells.append(subshells)
        # print(subshells)

        if new_body_info:
            shape_cache.add_cached_bid(
                cfg, "smd", this_bid, new_body_info, new_body_metadata, smd["footprint"]
            )

if do_pcb_proc:
    # Compute bounding box of PCB
    # FIXME: make this min, max code less verbose
    pcb_min_x = pcb_max_x = pcb_edge_points[0][0]
    pcb_min_y = pcb_max_y = pcb_edge_points[0][1]
    for pt in pcb_edge_points:
        pcb_min_x = min(pcb_min_x, pt[0])
        pcb_max_x = max(pcb_max_x, pt[0])
        pcb_min_y = min(pcb_min_y, pt[1])
        pcb_max_y = max(pcb_max_y, pt[1])

    pcb_bb_corners = [
        [pcb_min_x, pcb_min_y],
        [pcb_min_x, pcb_max_y],
        [pcb_max_x, pcb_min_y],
        [pcb_max_x, pcb_max_y],
    ]

    # Delaunay triangulation will be done on the following points
    # 1. centers of all considered footprints
    # 2. mounting holes
    # 3. representative corner points of PCB edge. mounting holes are
    #    inside the PCB and don't extend all the way to the edge.
    #    If we don't include them, we may end up having a separate
    #    "delaunay island", depending on the exact PCB shape
    pcb_edge_simple_points = edge_cuts.get_representative_verts(pcb_filled_shapes[0])
    for pt in pcb_edge_simple_points:
        pt[1] = -pt[1]

    pcb_edge_poly = Polygon(pcb_edge_points)
    inner_mh_centers = []
    # ignore mounting holes outside PCB for mesh calculation
    for pt in mounting_holes:
        if pcb_edge_poly.contains(Point(pt[0], pt[1])):
            inner_mh_centers.append(pt)
        else:
            print(
                "NOTE: Mounting hole at ",
                pt,
                " is out of PCB - will not be considered for mesh and minmesh",
            )

    dt_centers = fp_centers
    if cfg['jig']['type']=='TH_soldering':
        dt_centers += pcb_edge_simple_points
    else:
        dt_centers += inner_mh_centers

    extra_line_segments = []
    for start, end in cfg['holder']['base']['extra_lines']:

        if type(start) is str:
            pt_start = (ref_map[start]['x'], ref_map[start]['y'])
        else:
            pt_start = (start[0],-start[1])
        if type(end) is str:
            pt_end = (ref_map[end]['x'], ref_map[end]['y'])
        else:
            pt_end = (end[0],-end[1])
        extra_line_segments.append((pt_start, pt_end))

    mesh_line_segments = []
    if len(dt_centers) >= 4:
        mesh_comment = "delaunay triangulated mesh"
        d_verts = np.array(dt_centers)
        d_tris = scipy.spatial.Delaunay(d_verts)
        for tri in d_tris.simplices:
            # tri is a,b,c
            av = d_verts[tri[0]]
            a = [av[0], av[1]]
            bv = d_verts[tri[1]]
            b = [bv[0], bv[1]]
            cv = d_verts[tri[2]]
            c = [cv[0], cv[1]]
            mesh_line_segments.append([a, b])
            mesh_line_segments.append([b, c])
            mesh_line_segments.append([c, a])
    else:
        if len(dt_centers) > 1:
            av = dt_centers[0]
            a = [av[0], av[1]]
            bv = dt_centers[1]
            b = [bv[0], bv[1]]
            mesh_line_segments.append([a, b])
        if len(dt_centers) == 3:
            cv = dt_centers[2]
            c = [cv[0], cv[1]]
            mesh_line_segments.append([b, c])
            mesh_line_segments.append([c, a])

    minmesh_line_segments = []
    minmesh_centers = fp_centers + inner_mh_centers
    if cfg['jig']['type']=='TH_soldering':
        minmesh_centers += pcb_edge_simple_points
        frame_edge_points = pcb_edge_simple_points
    else:
        _edge_points = []
        for mh_name in mh_map:
            mh_pos = [mh_map[mh_name]["x"], mh_map[mh_name]["y"]]
            _edge_points.append(mh_pos)
        if len(_edge_points) > 0:
            _edge_points = np.array(_edge_points)
            frame_hull = scipy.spatial.ConvexHull(_edge_points)
            frame_edge_points = _edge_points[frame_hull.vertices]
            minmesh_centers = np.concatenate((minmesh_centers,frame_edge_points), axis=0)
        else:
            frame_edge_points = []
        print('Using mounting hole hull as frame edge')
    if len(minmesh_centers) > 2:
        # FIXME: should we not do minmesh if there are very large number of points !?
        # CPU could just hang if given large number of points... Of course, that can
        # generally happen if there are bugs in the program - typically we wouldn't
        # expect even 100 points to go for Travelling Salesman
        print("Computing minmesh nodes=%d..." % (len(minmesh_centers)))
        distance_matrix = euclidean_distance_matrix(
            np.array(minmesh_centers), np.array(minmesh_centers)
        )
        all_nodes = np.array(minmesh_centers)

        # NOTE: starting point of the travelling salesman problem will be a point
        # on the edge of the PCB, due to the way dt_centers is setup...

        # Using method from TSP docs https://github.com/fillipe-gsm/python-tsp
        # """
        # Finally, if you don't feel like fine-tunning the solvers for each problem,
        # a rule of thumb that worked relatively well for me is to run the SA with
        # a 2-opt and follow it by a LS with PS3 or PS6, like
        # """
        # Yeah, sure I don't like fine tuning the travelling salesman right now.
        # Will take this up later. FIXME
        #
        permutation, distance = solve_tsp_simulated_annealing(distance_matrix)
        permutation2, distance2 = solve_tsp_local_search(
            distance_matrix, x0=permutation, perturbation_scheme="ps3"
        )
        minmesh_path = all_nodes[permutation2].tolist()
    else:
        minmesh_path = minmesh_centers

    groove_lines = edge_cuts.compute_grooves(
        arc_resolution, pcb_filled_shapes[0], groove_size
    )
    # Align to 3D Y coordinates by negating
    groove_lines = [[[line[0][0],-line[0][1]],[line[1][0],-line[1][1]]] for line in groove_lines]

if do_pcb_proc and cfg["jig"]["mounting_hole_spacer_end"] == 0:
    if len(all_shells)==0:
        cfg["jig"]["mounting_hole_spacer_end"] = 0.0
        cfg["jig"]["mounting_hole_spacer_start"] = 0.0
        print("NOTE: No shells, spacer jig can't be made.")
    else:
        #
        # Find the second highest Z, without looking at values that are
        # too close to the topmost z. Spacer will run from this Z
        # to almost the bottom of the second tallest component on the
        # board, or the second support ring of any component that comes
        # lower.
        z_second_highest = -1
        h2_z_name = ""
        z_list = []
        #  little margin of error, to compensate for mis-aligned bergs ?
        thresh = topmost_z - 0.2
        for subshells in all_shells:
            this_ref = subshells["ref"]
            for shell_info in subshells["shell"]:
                for this_bin in shell_info["fitting_bins"]:
                    for tmz in [this_bin["end_z"], this_bin["start_z"]]:
                        if tmz < thresh and tmz > z_second_highest:
                            z_second_highest = tmz
                            h2_z_name = this_ref
                        elif tmz >= thresh and tmz < topmost_z:
                            print(
                                "WARNING: you have component %s at z=%s that is being ignored as it is too close to top height %s"
                                % (this_ref, tmz, topmost_z)
                            )
                        z_list.append(tmz)
        # unique
        z_list = list(set(z_list))
        z_list.sort()
        z_list = list(filter(lambda x: x>=0.0, z_list))
        print("Unique Zs are = ", z_list)

        # Without a second bin in z_list, results are undefined
        if len(z_list)>1:
            spacer_start = z_list[1]
            extra_layers = cfg["3dprinter"]["first_layer_height"] \
                           + cfg["3dprinter"]["layer_height"]
            mh_spacer_end = z_second_highest - extra_layers
            # one extra layer to have at-least one line show up
            spacer_start += extra_layers
            print(
                "Mounting hole spacer ends at Z=%s, component is %s"
                % (mh_spacer_end, h2_z_name)
            )
            print(
                "Mounting hole spacer start = %s, height= %s"
                % (spacer_start, mh_spacer_end - spacer_start)
            )
        else:
            spacer_start = 0.0
            mh_spacer_end = 0.0
            print("NOTE: Mounting hole spacer jig is not applicable for this design.")

        cfg["jig"]["mounting_hole_spacer_end"] = mh_spacer_end

        if cfg["jig"]["mounting_hole_spacer_start"] == 0:
            cfg["jig"]["mounting_hole_spacer_start"] = spacer_start

if (
    not cfg["jig"]["mounting_hole_bolt_is_external"]
    and not cfg["jig"]["mounting_hole_spacer_is_fused"]
):
    print("ERROR: can't have separate spacer with internal bolt")
    sys.exit(1)

try:
    if do_pcb_proc:
        gen_scad.generate_jig(
            fp_scad,
            config_text,
            cfg,
            args.pcb,
            args.config,
            args.keep_orientation,
            all_shells,
            fp_map,
            ref_map,
            mh_map,
            smd_keepouts,
            topmost_z,
            pcb_edge_points,
            frame_edge_points,
            dt_centers,
            extra_line_segments,
            mesh_line_segments,
            minmesh_path,
            groove_lines,
            pcb_min_x,
            pcb_max_x,
            pcb_min_y,
            pcb_max_y,
            not args.bottom_components
        )

    elif args.footprint or args.pcb_footprints:
        if args.grid and len(all_shells) > (grid_x * grid_y):
            print(
                "WARNING: There are more shells than grid elements. Shells shall be arranged consectively."
            )
        ref_arrange.arrange(
            cfg, fp_map, all_shells, args.arrange, gap_x, gap_y, grid_x, grid_y
        )
        gen_scad.generate_footprints(
            fp_scad,
            config_text,
            cfg,
            args.config,
            args.keep_orientation,
            all_shells,
            fp_map,
            ref_map,
            topmost_z,
        )
except ValueError as err:
    print(traceback.format_exc())
    print(f"ERROR: {err}", file=sys.stderr)
    sys.exit(-1)

# Done with the file
fp_scad.close()

if args.output_format in ["3mf", "stl"]:
    cmd = []
    # FIXME - ideally we'll have a config in ~/.config to store things
    # like paths to binaries etc
    cfg_scad = cfg["openscad"]
    cmd += [os.path.expanduser(cfg_scad["binary"]), "--hardwarnings"]
    if cfg_scad["use_manifold"]:
        cmd += ["--backend", "Manifold"]
    cmd += ["-o", out_filename, oscad_filename]
    print("Generating output using : %s" % (" ".join(cmd)))
    print("-----------------------------------------")
    retcode = subprocess.call(cmd)
    print("-----------------------------------------")
    if retcode != 0:
        print("ERROR: OpenSCAD Failed, exit code %d" % (retcode))
    else:
        print("Done, output : %s" % (out_filename))
    os.unlink(oscad_filename)

else:
    print("Done, output : %s" % (oscad_filename))
#
#
# Coordinate system notes:
#
# We adhere to the normal 3D coordinate system in this program,
# with Z pointing up.
#
# KiCAD uses a coordinate system where X increases to the right,
# and Y increases down - like a regular framebuffer. Therefore,
# Y coordinates from KiCAD needs to be negated to map to the
# regular 3D system. Note that 3D meshes in KiCAD use the regular
# 3D coordinate system, so those coordinates don't need to be
# transformed.
#
# This script also uses OpenSCAD. The extrude operation extrudes
# along the positive Z axis - i.e. upwards.
#
# Z = 0 corresponds to the bottom of the PCB. At the top of the
# PCB, Z = PCB thickness
#
# This setup is so that we can exactly match KiCAD's step file
# export of the board. Overlaying the mesh generated on this
# program on top of the step file is useful both for debugging
# as well as understanding any issues.
#
# Here is the Z coordinate stackup, for top side assembly.
# Soldering is on the bottom side.
#
# Z = topmost + 1 | "base". Start of 1 mm thick layer, delaunay triangles
#     +thickness  |
#
# Z = topmost     | topmost point of tallest component, when mounted on
#     +thickness | the PCB. Typically the long end of a berg header
#
# Z = in-between  | Highest point of intermediate height component
#
# Z = thickness+  | Start of typical shell
#     clearance   | Clearance allows user to visually verify component
#                 | placement and fit from the sides
#
# Z = thickness   | PCB top
#
# Z = 0           | PCB botto
#
# This program uses this terminology
#
# edge      => closed polygon matching exact border.
#              e.g. the outer edge of the PCB. In the case of a component
#              you can think of a projection of the 3d model of
#              the component onto the Z plane, and the resulting outline.
#              outlines can be concave.
#
# hull      => convex hull of the edge. Typically used as these are
#              easier to compute and have useful properties. Using
#              concave surfaces needs more care, else things may break.
#
# overlap   => small inset of the edge/hull.
#              offset value here is called "overlap" as well.
#
# outline    => small offset of the edge/hull (meaning outwards)
#               offset value here is called "gap"
#
# perimeter => large offset of the edge/hull. Typically used to
#              build "walls" or shells
#              offset value here is termed "thickness"
#
# component/board can slide inside outline, but will abut above an
# overlap. The term "clearance" is used to a gap in the
# Z direction.
#
# "pocket" is a negative shape - e.g. the hollow cavity required
# to push in a component
#
# "shell" is a solid shape with a cavity. the cavity is a "pocket" so
# that the component can be held in the pocket.
#
#
